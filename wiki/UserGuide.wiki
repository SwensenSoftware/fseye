#summary Installation instructions and user manual
#labels Featured,Phase-Deploy

= Installation =

  * Download and unzip featured release of FsEye from the [http://code.google.com/p/fseye/downloads/list Downloads] page
  * Load FsEye.fsx within an FSI session, e.g. {{{#load @"C:\FsEye\FsEye.fsx"}}}. This will automatically bring {{{eye}}} into scope for programmatically manipulating FsEye as well as attaching a listener to the FSI session to automatically add and update FsEye watches.
  * Open Swensen.FsEye within .fs files in order to gain intellisense to the open {{{eye}}} instance.

= Manual =

== Adding and updating watches ==

Adding and updating watches is done one of two ways:
  # Send let bindings (or unnamed "it" bindings) to the F# Interactive, FsEye will automatically add, or update an existing, watch in the GUI tree view.
  # Programmatically add, or update an existing, watch using {{{eye.Watch(name:string, value:'a)}}}, e.g. {{{eye.Watch("watchName", 28.2f)}}}

An existing root watch may also be refreshed (for example, if its value has been mutated) via the GUI tree right-click context menu -> Refresh.

== Navigating watches ==

Watch sub-nodes are loaded on demand upon expanding a tree node. Loading is done asynchronously and in parallel. When a watch is fully loaded, it will display the true type of its value (as opposed to the member's reflected possibly super type) along with a text representation of its value. Zero-arg non-void method sub-nodes will not be fully loaded immediately along with field and property nodes upon expansion: they are loaded when selected or expanded.

A watch's value may be copied to the Clipboard via the context menu -> Copy Value. If a watch has no value, or it's value has not completely loaded, the Copy Value menu item will be disabled.

== Archiving watches ==

Archiving allows you to take a snapshot of all current root watches, consolidating them as children of an archive root node. Future watches of the same name will be added freshly to the GUI tree, and the archived watches of the same name will not be updated. This is especially useful for watching how a value changes over the course of several iterations of a loop.

Root watches may be archived using the GUI Archive button or via {{{eye.Archive(label:string)}}} or {{{eye.Archive()}}}. The Archive button uses the latter parameterless Archive method, which uses an internal archive count as part of a default label.

== Clearing archives and watches ==

Archives and watches may be cleared using the Clear Archives, Clear Watches, or Clear All (i.e. clear both watches and archives) GUI buttons as well as using {{{eye.ClearArchives()}}}, {{{eye.ClearWatches()}}} and {{{eye.ClearAll()}}}. Clear All and Clear Archives reset the internal archive count.

Archives and root watches may be individually removed using the context menu -> Remove.

== Async break and continue ==

A particularly novel feature of FsEye is the ability to perform debugger-like "break" and "continue" within {{{async}}} blocks. When code executing inside an async block executes {{{do! eye.AsyncBreak()}}}, execution is suspending until the user clicks the Async Continue button on the GUI or uses {{{eye.AsyncContinue()}}}. For example,

{{{
async {
    for i in 1..40 do
        eye.Watch("i", i)
        eye.Watch("i*2", i*2)
        eye.Archive()
        if i % 10 = 0 then
            do! eye.AsyncBreak()
} |> Async.StartImmediate
}}}

== The FSI Listener ==

By default, FsEye in enabled to listen to FSI adding and updating watches as commands are entered. This may be enabled or disabled using {{{eye.Listen}}}.

== Window visibility ==

The FsEye window is designed never to dispose, even if it is closed. It shows automatically whenever a watch is added or updated through FSI listening, and whenever an "async breakpoint" is encountered. It is not shown automatically when watches are added or updated programmatically. It may also be manually shown using {{{eye.Show()}}} or manually hidden using {{{eye.Hide()}}}